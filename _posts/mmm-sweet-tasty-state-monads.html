title: Mmm... sweet tasty state monads
date: 2011/12/12 15:24:03 -0800
tags: []
author: David Pollak
alias: /mmm-sweet-tasty-state-monads

One of the really challenging things about Haskell is the lack of state... or more specifically, the lack of global state. <p /><div>In Scala there are a ton of places you can put state (stuff that&#39;s mutated across method invocations.)  You can use globals, thread-local variables (something that Lift makes heavy use of), and instance variables.  Here are some examples:</div> <p /><div>Global:</div><p /><div>object MyState {</div><div>  private var cnt = 0</div> <p /><div>  def inc = synchronized {cnt += 1}</div><div>   def dec = synchronized {cnt -= 1}</div><div>  def getCnt = synchronized {cnt}</div> <div>}</div><p /><div>Instance variables are pretty much the same, except you have to pass the instance around:</div><p /><div> <div>class MyState {</div><div>  private var cnt = 0</div><p /><div>  def inc = synchronized {cnt += 1}</div><div>  def dec = synchronized {cnt -= 1}</div> <div>  def getCnt = synchronized {cnt}</div><div>}</div></div><p /><div>In Haskell, there&#39;s no mutability, so if you have a reference to a chunk of data, the data will never change.  In order to change the state, you must create a new instance, but any holder of the old reference see the old data.  In general, this is a GoodThing™ because you don&#39;t have to worry about state changing out from under you, but it makes accumulating state pretty difficult.  For example, if we want to count the number of hellos and goodbyes and accumulate the names of the people who said Hello or Goodbye, it&#39;s easy to do:</div> <p /><div><div>val state = new MyState</div><p /> <div>val greeters = List((&quot;David&quot;, &quot;Hello&quot;), (&quot;Archer&quot;, &quot;Woof&quot;), (&quot;Annette&quot;, &quot;Bye&quot;)).flatMap {</div> <div>  case (name, &quot;Hello&quot;) =&gt; state.inc ; List(name)</div><div>  case (name, &quot;Bye&quot;) =&gt; state.dec ; List(name)</div> <div>  case _ =&gt; Nil</div><div>}</div><p /></div><div>At the end of the above execution, we have a list of people who have made greetings and the side effect of updating the state object with the net Hello/Bye count.</div><p /><div>In Haskell, without the State monad, we&#39;d have to accumulate both the count and the names and then fold across them:</div> <p /><div><div>list = [(&quot;David&quot;, &quot;Hello&quot;), (&quot;Archer&quot;, &quot;Woof&quot;), (&quot;Annette&quot;, &quot;Bye&quot;)]</div> <p /><div>gTest (name, &quot;Hello&quot;) = (1, [name])</div> <div>gTest (name, &quot;Bye&quot;) = (-1, [name])</div><div>gTest _ = (0, [])</div> <p /><div>acc = map gTest list</div><p /><div>sumIt (i1, n1) (i2, n2) = (i1 + i2, n1 ++ n2)</div><p /><div>summed = foldr1 sumIt acc</div></div><p /><div>As the state that we carry around becomes more complex, it.  Further, having to fold our result in sumIt is counterintuitive.  We&#39;ve already done the calculation, why do we have to fold the pairs into the final result?</div> <p /><div>There&#39;s a simpler way to carry state around in Haskell.  Here&#39;s an example:</div><p /><div><div>-- the stateful test</div> <div>sTest v = </div><div><span class="Apple-tab-span" style="">	</span>do </div> <div><span class="Apple-tab-span" style="">		</span>i &lt;- get -- get the current state</div><div><span class="Apple-tab-span" style="">		</span>case v of</div> <div><span class="Apple-tab-span" style="">			</span>-- update the state and then return the value</div><div><span class="Apple-tab-span" style="">			</span>(name, &quot;Hello&quot;) -&gt; put (i + 1) &gt;&gt; return [name]</div> <div><span class="Apple-tab-span" style="">			</span>(name, &quot;Bye&quot;) -&gt; put (i - 1) &gt;&gt; return [name]</div><div> <span class="Apple-tab-span" style="">			</span>_ -&gt; return []</div><p /><div>sAcc = (mapM sTest list)</div><p /><div> sSummed = mapFst concat $ runState sAcc 0</div></div><p /><div>In the above code, we&#39;re separating the state from the core name calculation.  The get function get the state into the variable i.  Depending on the greeting, we increment, decrement or ignore the state.</div> <p /><div>Now, the thing that confused me for years about the State monad was where &quot;get&quot; was getting from and where &quot;put&quot; was putting it.  Well, it&#39;s like this, the State Monad is actually some accumulated functions that are &quot;played&quot; by the runState function.  sAcc function returns a bunch of functions.  The runState function takes that function and a seed value (in this case, 0), and plays the function to get the resulting information and the resulting state.</div> <p /><div>The State Monad makes stuff like parsing and keeping state while parsing (e.g., the current count of AST elements we&#39;ve encountered) is very powerful and makes Haskell code that is in effect imperative a lot easier to write.</div> <p /><div>I recently tried to implement Hindley-Milner type inferencing without the State Monad and the code was nasty and complex with lots of state being returned all over the place (see <a href="https://github.com/visi-lang/visi/commit/cfe7d6fe5a6b25795a1c32ab2f18cfcbad1f9b54#diff-1">https://github.com/visi-lang/visi/commit/cfe7d6fe5a6b25795a1c32ab2f18cfcbad1f9b54#diff-1</a> and all the atv, atv&#39;, etc. state) and then <a href="https://github.com/visi-lang/visi/blob/b8f06c73f66596af8333ab09d9528bada068a188/core/src/Visi/Typer.hs">https://github.com/visi-lang/visi/blob/b8f06c73f66596af8333ab09d9528bada068a188/core/src/Visi/Typer.hs</a>  Note that all the state stuff is handled in the State Monad rather than cluttering up the logic of the code.  I&#39;ve come to really like the State Monad a lot... it makes me feel somewhat imperative while being functional. ;-)</div>
